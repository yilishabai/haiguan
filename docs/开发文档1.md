这是一个可以直接分发给后端和前端开发团队的**技术实施规范文档**。我已将之前的策略转化为具体的伪代码、数据逻辑和API规范。

-----

# 跨境供应链协同平台——大屏实时数据仿真实施文档

**版本**：1.0
**状态**：待开发
**目标**：在低频真实业务背景下，通过后台仿真脚本驱动，实现看板数据的“高频呼吸感”与“全链路真实流转”，确保演示效果生动且逻辑闭环。

-----

## 1\. 总体架构策略 (Simulation Strategy)

为了实现“真实感”，我们将数据更新分为三个维度。后台需运行一个独立的守护进程（Daemon/Script），按以下频率和逻辑操作数据库：

| 维度 | 更新频率 | 目标指标 | 核心逻辑 |
| :--- | :--- | :--- | :--- |
| **L1 呼吸层** | 高频 (2s - 5s) | 响应时间、在线企业数、成功率 | **基准值 + 正弦波动 + 随机噪声**。模拟服务器负载的自然起伏。 |
| **L2 增量层** | 中频 (30s - 60s) | GMV、今日订单量、日志列表 | **小步快跑**。模拟新订单不断进场。 |
| **L3 流转层** | 低频 (1min - 3min) | 流程漏斗、状态分布、物流进度 | **状态机流转**。对存量数据进行 UPDATE 操作，模拟业务推进（下单→报关→发货）。 |

-----

## 2\. 数据库仿真逻辑 (Backend Implementation)

*以下字段名称均严格参照 `backend_py/app.db` 数据字典。*

### 2.1 L1 呼吸层：系统负载仿真

**逻辑**：不直接修改数据库，建议通过 Redis 或内存变量维护，前端接口读取。

  * **响应时间 (Latency)**: 模拟 `model_execution_logs.latency_ms` 的实时均值。
      * *算法*: `Base(1.5s) + Sin(Time) * 0.2 + Random(-0.1, 0.1)`
      * *效果*: 曲线平滑波动，而非锯齿状跳变。
  * **成功率 (Success Rate)**:
      * *算法*: `99.5% - (Random(0, 0.5) if Random() > 0.8 else 0)`
      * *效果*: 大部分时间稳定，偶尔出现微小跌幅。

### 2.2 L2 增量层：新业务注入 (New Order Injection)

**动作**：向 `orders` 表和 `model_execution_logs` 表插入新数据。

**数据构造规则**:

1.  **Enterprise**: 从预设列表（如“深圳电子科技”、“宁波服装贸易”）中随机读取。
2.  **Category**: 随机选自 `['beauty', 'electronics', 'wine', 'textile', 'appliance']`。
3.  **Amount**: `Random(1000, 50000)`。
4.  **Status**: 初始必须为 `'pending'`。
5.  **联动插入**:
      * 同时向 `model_execution_logs` 插入一条记录，`model_name` 随机选自“风控模型V2.1”、“支付路由模型”。
      * `business_outcome` 设为 `'OK'` 或 `'release'`。

### 2.3 L3 流转层：全链路状态机 (Workflow Engine)

**核心价值**：这是让“漏斗图”和“状态列表”动起来的关键。脚本需定期扫描数据库并更新旧数据状态。

**状态流转逻辑 (Python伪代码)**:

```python
def simulate_workflow_step():
    # 阶段 1: 模拟报关 (Pending -> Customs)
    # 选取 15% 的 pending 订单推进到 customs
    db.execute("""
        UPDATE orders SET status = 'customs' 
        WHERE id IN (SELECT id FROM orders WHERE status='pending' ORDER BY RANDOM() LIMIT 2)
    """)
    # 同步更新关联的 customs_headers 表（如有）状态为 'processing'

    # 阶段 2: 模拟放行发货 (Customs -> Shipping)
    # 选取 20% 的 customs 订单推进到 shipping
    db.execute("""
        UPDATE orders SET status = 'shipping' 
        WHERE id IN (SELECT id FROM orders WHERE status='customs' ORDER BY RANDOM() LIMIT 1)
    """)
    # 同步更新 logistics 表状态为 'transit'

    # 阶段 3: 模拟异常注入 (Chaos Engineering)
    # 极低概率将某订单标记为风险
    if random.random() < 0.05:
         db.execute("UPDATE settlements SET risk_level = 'high' WHERE status='processing' LIMIT 1")
```

-----

## 3\. 前端取值与展示规范 (Frontend Specs)

为了配合后端仿真，前端需在视觉上进行处理。

### 3.1 核心指标卡 (Key Metrics)

  * **字段**: GMV (`orders.amount` 总和), 活跃订单数。
  * **展示要求**:
      * **CountUp 动画**: 数值变化时，必须使用滚动增加动画（Duration 1s），禁止直接跳变。
      * **增量检查**: 确保 GMV 只增不减（除非重置数据）。

### 3.2 实时列表 (Live Feed)

  * **对应页面**: `image_7a8407.jpg` (全流程案例追踪)。
  * **展示要求**:
      * **柔和插入**: 轮询检测到新 `model_execution_logs` 时，使用 `FadeInDown` 动画将新行推入顶部。
      * **状态映射**: 严格按照数据字典映射颜色。
          * `release`/`OK` -\> \<span style="color:green"\>绿色 (放行)\</span\>
          * `risk`/`manual-review` -\> \<span style="color:orange"\>橙色 (风险复核)\</span\>

### 3.3 流程漏斗 (Funnel Chart)

  * **对应页面**: `image_7a8448.jpg` (流程漏斗)。
  * **逻辑**:
      * 定时（每5秒）重新聚合各状态的 Count 值。
      * 由于后台脚本在不断执行 `UPDATE` 操作，前端会看到柱状图的高度在缓慢、有机地变化（例如“支付”柱子高度下降，“物流”柱子高度上升）。

### 3.4 异常报警 (Alerts)

  * **触发条件**: 当接口返回包含 `risk_level='high'` 或 `logistics.status='exception'` 的新数据时。
  * **视觉反馈**:
      * 顶部“风险拦截次数”指示器闪烁红光。
      * 地图上对应的路线变成红色脉冲线。

-----

## 4\. 开发执行清单 (Action Items)

### 后端开发

  - [ ] 编写 `simulation.py` 脚本，包含 L1, L2, L3 三层逻辑。
  - [ ] 确保脚本直接操作 SQLite `app.db`，且包含 `commit()` 操作。
  - [ ] 修正 `orders` 与 `logistics`/`customs_headers` 的关联外键，确保更新 `orders` 状态时不会导致数据不一致。

### 前端开发

  - [ ] 封装统一的 `useRealtimeData` Hook，每 3-5 秒轮询一次后端聚合接口。
  - [ ] 引入 `CountUp.js` 或类似库处理数字跳动。
  - [ ] 检查所有状态标签（Status Tag）是否覆盖了数据字典中的 `pending`, `processing`, `customs`, `shipping`, `completed`。

-----

**备注**:
此方案不需要修改现有的业务代码架构，只需挂载一个额外的 Python 脚本不断产生“幽灵数据”即可。演示结束后，只需重置 SQLite 数据库文件即可恢复初始状态。